library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity display_text is
    port (
        clk           : in  std_logic;
        pixel_row     : in  std_logic_vector(9 downto 0);
        pixel_column  : in  std_logic_vector(9 downto 0);
        font_scale    : in  integer range 1 to 4 := 1; -- font scaling factor
        text_rgb      : out std_logic_vector(11 downto 0);
        text_on       : out std_logic
    );
end entity;

architecture Behavioral of display_text is

    component char_rom
        port (
            character_address : in  std_logic_vector(5 downto 0);
            font_row          : in  std_logic_vector(2 downto 0);
            font_col          : in  std_logic_vector(2 downto 0);
            clock             : in  std_logic;
            rom_mux_output    : out std_logic
        );
    end component;

    constant RIGHT_TEXT     : string := "100";
    constant BASE_CHAR_SIZE : integer := 8;
    constant TEXT_LENGTH    : integer := RIGHT_TEXT'length;
    signal font_row, font_col : std_logic_vector(2 downto 0);
    signal character_address  : std_logic_vector(5 downto 0);
    signal text_pixel         : std_logic := '0';

    signal scaled_char_width, scaled_char_height : integer;
    signal start_x, start_y : integer;

begin

    scaled_char_width <= BASE_CHAR_SIZE * font_scale;
    scaled_char_height <= BASE_CHAR_SIZE * font_scale;
    start_x <= 640 - scaled_char_width * TEXT_LENGTH;
    start_y <= 10;

    char_rom_inst : char_rom
        port map (
            character_address => character_address,
            font_row          => font_row,
            font_col          => font_col,
            clock             => clk,
            rom_mux_output    => text_pixel
        );

    process(clk)
        variable char_index : integer;
        variable local_row, local_col : integer;
    begin
        if rising_edge(clk) then
            text_on <= '0';
            text_rgb <= (others => '0');

            if unsigned(pixel_row) >= start_y and unsigned(pixel_row) < start_y + scaled_char_height then
                for i in 0 to TEXT_LENGTH - 1 loop
                    if unsigned(pixel_column) >= start_x + i * scaled_char_width and
                       unsigned(pixel_column) <  start_x + (i + 1) * scaled_char_width then

                        char_index := i + 1;
                        character_address <= std_logic_vector(to_unsigned(character'pos(RIGHT_TEXT(char_index)), 6));

                        local_row := (to_integer(unsigned(pixel_row)) - start_y) / font_scale;
                        local_col := (to_integer(unsigned(pixel_column)) - (start_x + i * scaled_char_width)) / font_scale;

                        font_row <= std_logic_vector(to_unsigned(local_row mod 8, 3));
                        font_col <= std_logic_vector(to_unsigned(local_col mod 8, 3));

                        if text_pixel = '1' then
                            text_on <= '1';
                            text_rgb <= "111100000000"; -- red text
                        end if;
                    end if;
                end loop;
            end if;
        end if;
    end process;

end architecture;
